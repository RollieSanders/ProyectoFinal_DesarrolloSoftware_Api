# .github/workflows/deploy.yml - Versión Corregida
name: CI/CD a AWS ECS con Fargate

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  AWS_REGION: us-east-1 # Asegúrate de que coincida con tu Terraform
  # Estos nombres deben coincidir con tus recursos de Terraform
  ECR_REPOSITORY_FRONTEND: proyectofinal-frontend
  ECR_REPOSITORY_BACKEND: proyectofinal-backend
  ECS_CLUSTER: proyectofinal-cluster
  ECS_SERVICE: proyectofinal-service
  ECS_TASK_DEFINITION: proyectofinal-task-definition 

jobs:
  deploy:
    name: Build, Push y Despliegue
    runs-on: ubuntu-latest

    steps:
      - name: Checkout del Código
        uses: actions/checkout@v4

      # -------------------------------------------------------------------------
      # ⚠️ CORRECCIÓN 1: Instalar la herramienta 'jq' antes de usarla
      # -------------------------------------------------------------------------
      - name: Instalar jq (para manipular JSON de Task Definition)
        run: sudo apt-get update && sudo apt-get install -y jq

      # -------------------------------------------------------------------------
      #  Paso 0: Configurar Credenciales AWS
      # -------------------------------------------------------------------------
      - name: Configurar Credenciales de AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # -------------------------------------------------------------------------
      # Paso diagnóstico: comprobar credenciales y recursos ECS disponibles
      # -------------------------------------------------------------------------
      - name: Diagnostics AWS (credenciales y recursos ECS)
        run: |
          echo "Comprobando identidad de AWS..."
          aws sts get-caller-identity || { echo "Fallo al obtener identidad (revisa secrets)."; exit 2; }
          echo "Listado de Task Definitions (prefijo familia: ${{ env.ECS_TASK_DEFINITION }})"
          aws ecs list-task-definitions --family-prefix ${{ env.ECS_TASK_DEFINITION }} --region ${{ env.AWS_REGION }} || true
          echo "Listado de clusters ECS"
          aws ecs list-clusters --region ${{ env.AWS_REGION }} || true

      # -------------------------------------------------------------------------
      #  Paso 1: BUILD y PUSH del Backend (Python)
      # -------------------------------------------------------------------------
      - name: Login en Amazon ECR (Backend)
        id: login-ecr-backend
        uses: aws-actions/amazon-ecr-login@v2
        
      - name: Build, Tag y Push de la imagen Backend
        id: build-image-backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-backend.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }} 
        run: |
          # El contexto de backend/ permite usar recursos como requirements.txt dentro de esa carpeta
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG -f backend/Dockerfile ./backend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG
          # Se establece la URI de la imagen para el paso de actualización de la Task Definition
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_BACKEND:$IMAGE_TAG" >> $GITHUB_ENV

      # -------------------------------------------------------------------------
      #  Paso 2: BUILD y PUSH del Frontend (Vue.js)
      # -------------------------------------------------------------------------
      - name: Login en Amazon ECR (Frontend)
        id: login-ecr-frontend
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build, Tag y Push de la imagen Frontend
        id: build-image-frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-frontend.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG -f frontend/Dockerfile ./frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG
          # Se establece la URI de la imagen para el paso de actualización de la Task Definition
          echo "FRONTEND_IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY_FRONTEND:$IMAGE_TAG" >> $GITHUB_ENV
          
      # -------------------------------------------------------------------------
      #  Paso 3: Despliegue en ECS (Actualizar la Task Definition y el Servicio)
      # -------------------------------------------------------------------------
      - name: Descargar, Actualizar y Registrar la nueva Task Definition
        id: update-task-def
        run: |
          # 1. Obtener la definición de tarea actual (la última activa)
          TASK_DEF_JSON=$(aws ecs describe-task-definition \
            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
            --query 'taskDefinition' --output json --region ${{ env.AWS_REGION }}) || true

          if [ -z "$TASK_DEF_JSON" ] || [ "$TASK_DEF_JSON" = "null" ]; then
            echo "INFO: No existe la Task Definition '${{ env.ECS_TASK_DEFINITION }}'. Intentando crearla desde la plantilla..."
            # Asegurarse de que exista envsubst para sustituir variables en la plantilla
            sudo apt-get update && sudo apt-get install -y gettext-base

            # Exportar variables para envsubst (usadas por la plantilla)
            export family="${{ env.ECS_TASK_DEFINITION }}"
            export frontend_image_uri="${{ env.FRONTEND_IMAGE_URI }}"
            export backend_image_uri="${{ env.IMAGE_URI }}"
            export ecs_execution_role_arn="${{ secrets.ECS_EXECUTION_ROLE_ARN }}"
            export ecs_task_role_arn="${{ secrets.ECS_TASK_ROLE_ARN }}"
            export aws_region="${{ env.AWS_REGION }}"
            export db_endpoint="${{ secrets.DB_ENDPOINT }}"

            # Si no hay DB_ENDPOINT en secrets, intentar obtenerlo desde Terraform (si existe)
            if [ -z "$db_endpoint" ] || [ "$db_endpoint" = "placeholder-db-endpoint.com" ]; then
              echo "DB_ENDPOINT no proporcionado en secrets o es placeholder. Intentando obtener desde Terraform state..."
              if command -v terraform >/dev/null 2>&1; then
                db_endpoint=$(terraform -chdir=terraform output -raw db_endpoint 2>/dev/null || true)
                echo "DB_ENDPOINT desde terraform: $db_endpoint"
              fi
            fi

            if [ -z "$db_endpoint" ] || [ "$db_endpoint" = "placeholder-db-endpoint.com" ]; then
              echo "ERROR: DB_ENDPOINT no configurado. Añade el secret 'DB_ENDPOINT' o configura Terraform output 'db_endpoint'.";
              exit 1;
            fi

            if [ -z "$ecs_execution_role_arn" ] || [ -z "$ecs_task_role_arn" ]; then
              echo "ERROR: faltan secrets 'ECS_EXECUTION_ROLE_ARN' o 'ECS_TASK_ROLE_ARN'. Añade estos secretos y reintenta.";
              exit 1;
            fi

            # Construir JSON substituyendo variables en la plantilla
            envsubst < terraform/ecs_task_definition.json.tpl > /tmp/td.json

            echo "Task Definition JSON generado:";
            cat /tmp/td.json | jq . || true

            # Registrar la nueva Task Definition
            aws ecs register-task-definition --cli-input-json file:///tmp/td.json --region ${{ env.AWS_REGION }} || { echo "ERROR: registro fallido"; exit 1; }

            # Recuperar el ARN recién registrado
            NEW_TASK_ARN=$(aws ecs list-task-definitions --family-prefix "${{ env.ECS_TASK_DEFINITION }}" --region ${{ env.AWS_REGION }} --query 'taskDefinitionArns[-1]' --output text)
            echo "new_task_arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT
            echo "Registrada Task Definition: $NEW_TASK_ARN"
            exit 0
          fi

          # 2. Limpiar metadatos innecesarios para el registro
          CLEAN_TASK_DEF=$(echo $TASK_DEF_JSON | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .deregisteredAt, .registeredBy)')

          # 3. Actualizar URI de las imágenes en la definición de tarea
          UPDATED_TASK_DEF=$(echo $CLEAN_TASK_DEF | \
            jq --arg FRONTEND_URI "${{ env.FRONTEND_IMAGE_URI }}" '.containerDefinitions |= map(if .name == "frontend-container" then .image = $FRONTEND_URI else . end)' | \
            jq --arg BACKEND_URI "${{ env.IMAGE_URI }}" '.containerDefinitions |= map(if .name == "backend-container" then .image = $BACKEND_URI else . end)' | \
            jq --arg DB_ENDPOINT "$db_endpoint" '.containerDefinitions |= map(if .name == "backend-container" then (.environment |= ( (map(select(.name != "DB_HOST")) // []) + [{"name":"DB_HOST","value":$DB_ENDPOINT}])) else . end)')

          # 4. Registrar la nueva Task Definition
          NEW_TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$UPDATED_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' --output text --region ${{ env.AWS_REGION }})

          echo "new_task_arn=$NEW_TASK_ARN" >> $GITHUB_OUTPUT # Guardar el ARN para el siguiente paso

      - name: Despliegue al Servicio ECS
        run: |
          echo "Desplegando servicio ECS con la nueva Task Definition: ${{ steps.update-task-def.outputs.new_task_arn }}"
          aws ecs update-service --cluster ${{ env.ECS_CLUSTER }} --service ${{ env.ECS_SERVICE }} --task-definition "${{ steps.update-task-def.outputs.new_task_arn }}" --region ${{ env.AWS_REGION }} || { echo "ERROR: fallo al actualizar el servicio ECS"; exit 1; }
          echo "Esperando a que el servicio esté estable (polling)..."
          CLUSTER=${{ env.ECS_CLUSTER }}
          SERVICE=${{ env.ECS_SERVICE }}
          REGION=${{ env.AWS_REGION }}
          ATTEMPTS=5
          SLEEP=10
          ok=false
          for i in $(seq 1 $ATTEMPTS); do
            echo "Attempt $i/$ATTEMPTS: checking service status..."
            DESCRIBE=$(aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --region "$REGION")
            echo "$DESCRIBE" | jq .
            running=$(echo "$DESCRIBE" | jq -r '.services[0].runningCount')
            desired=$(echo "$DESCRIBE" | jq -r '.services[0].desiredCount')
            deployments=$(echo "$DESCRIBE" | jq -r '.services[0].deployments | length')
            echo "running=$running desired=$desired deployments=$deployments"
            if [ "$running" != "null" ] && [ "$running" -ge "$desired" ] && [ "$deployments" -eq 1 ]; then
              echo "Service is stable (running >= desired and single deployment)."
              ok=true
              break
            fi
            sleep $SLEEP
          done

          if [ "$ok" != "true" ]; then
            echo "ERROR: service did not become stable after $((ATTEMPTS*SLEEP)) seconds. Gathering diagnostics..."
            echo "--- ECS Service Description ---"
            aws ecs describe-services --cluster "$CLUSTER" --services "$SERVICE" --region "$REGION" || true
            echo "--- ECS Tasks (list) ---"
            aws ecs list-tasks --cluster "$CLUSTER" --service-name "$SERVICE" --region "$REGION" || true
            TASKS=$(aws ecs list-tasks --cluster "$CLUSTER" --service-name "$SERVICE" --region "$REGION" --output text --query 'taskArns') || true
            if [ -n "$TASKS" ]; then
              echo "--- ECS Tasks (describe) ---"
              aws ecs describe-tasks --cluster "$CLUSTER" --tasks $TASKS --region "$REGION" || true
            fi
            echo "--- Target Group Health (if applicable) ---"
            # try to find target group ARN from the service's loadBalancers (container -> targetGroupArn)
            TG_ARN=$(echo "$DESCRIBE" | jq -r '.services[0].loadBalancers[0].targetGroupArn // empty') || true
            if [ -n "$TG_ARN" ]; then
              echo "TargetGroup ARN: $TG_ARN"
              aws elbv2 describe-target-health --target-group-arn "$TG_ARN" --region "$REGION" || true
            else
              echo "No target group ARN found in service description."
            fi
            echo "--- CloudWatch Logs (last 200 events per log stream if available) ---"
            LOG_GROUP='/ecs/proyectofinal'
            streams=$(aws logs describe-log-streams --log-group-name "$LOG_GROUP" --order-by LastEventTime --descending --limit 5 --region "$REGION" --query 'logStreams[].logStreamName' --output text) || true
            for s in $streams; do
              echo "---- Logs from $s ----"
              aws logs get-log-events --log-group-name "$LOG_GROUP" --log-stream-name "$s" --limit 200 --region "$REGION" || true
            done
            exit 1
          fi